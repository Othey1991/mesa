// Generated by CoffeeScript 1.8.0
var Promise, helpers, mesa, mohair, payload, phase, setQueueProperties, _, _i, _len, _ref,
  __slice = [].slice;

mohair = require('mohair');

Promise = require('bluebird');

_ = require('lodash');

helpers = {};

helpers.schemaAwareEscape = function(string) {
  return string.split('.').map(function(str) {
    return "\"" + str + "\"";
  }).join('.');
};

helpers.defaultMohair = mohair.escape(helpers.schemaAwareEscape).returning('*');

helpers.replacePlaceholders = function(sql) {
  var index;
  index = 1;
  return sql.replace(/\?/g, function() {
    return '$' + index++;
  });
};

helpers.ignoredArgumentWarning = function(receiver) {
  return "you called " + receiver + " with an argument but " + receiver + " ignores all arguments. " + receiver + " returns a promise and maybe you wanted to call that promise instead: " + receiver + ".then(function(result) { ... })";
};

mesa = {
  fluent: function(key, value) {
    var object;
    object = Object.create(this);
    object[key] = value;
    return object;
  },
  _returnFirst: false,
  returnFirst: function(arg) {
    if (arg == null) {
      arg = true;
    }
    return this.fluent('_returnFirst', arg);
  },
  table: function(arg) {
    return this.fluent('_mohair', this._mohair.table(arg));
  },
  getTable: function() {
    return this._mohair.getTable();
  },
  debug: function(arg) {
    return this.fluent('_debug', arg);
  },
  _allowed: [],
  allow: function() {
    var columns;
    columns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_allowed', _.flatten(columns));
  },
  _isUnsafe: false,
  unsafe: function(isUnsafe) {
    if (isUnsafe == null) {
      isUnsafe = true;
    }
    return this.fluent('_isUnsafe', isUnsafe);
  },
  pickAllowed: function(record) {
    if (this._isUnsafe) {
      return record;
    }
    if (this._allowed.length === 0) {
      throw new Error(['no columns are allowed.', 'this will make .update() or .insert() fail.', 'call .allow(columns...) with at least one column before .insert() or .update().', 'alternatively call .unsafe() before to disable mass assignment protection altogether.'].join(' '));
    }
    return _.pick(record, this._allowed);
  },
  _primaryKey: 'id',
  primaryKey: function(arg) {
    return this.fluent('_primaryKey', arg);
  },
  getPrimaryKey: function() {
    return this._primaryKey;
  },
  embedBelongsTo: function(records, table, options) {
    var condition;
    condition = {};
    condition[options.primaryKey] = _.pick(records, options.foreignKey);
    return options.table.where(condition).then(function(otherRecords) {
      var grouped;
      grouped = _.groupBy(otherRecords, options.primaryKey);
      records.forEach(function(record) {
        var foreignKey;
        foreignKey = record[options.foreignKey];
        return record[options.as] = grouped[foreignKey][0];
      });
      return records;
    });
  },
  queueEmbedBelongsTo: function(table, options) {
    var otherTableName, _ref;
    this.queueAfter(function(records) {});
    otherTableName = (_ref = options.table) != null ? typeof _ref.getTable === "function" ? _ref.getTable() : void 0 : void 0;
    if (otherTableName == null) {
      throw new Error('options.table must be a mesa instance');
    }
    if (options.foreignKey == null) {
      options.foreignKey = otherTableName + '_id';
    }
    if (options.primaryKey == null) {
      options.primaryKey = otherTableName.getPrimaryKey();
    }
    if (options.as == null) {
      options.as = tableName;
    }
    return this.after(function(records) {});
  },
  queueEmbedHasOne: function(options) {},
  _mohair: helpers.defaultMohair,
  sql: function(escape) {
    return this._mohair.sql(escape);
  },
  params: function() {
    return this._mohair.params();
  },
  raw: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (_ref = this._mohair).raw.apply(_ref, args);
  },
  where: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).where.apply(_ref, args));
  },
  having: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).having.apply(_ref, args));
  },
  join: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).join.apply(_ref, args));
  },
  select: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).select.apply(_ref, args));
  },
  limit: function(arg) {
    return this.fluent('_mohair', this._mohair.limit(arg));
  },
  offset: function(arg) {
    return this.fluent('_mohair', this._mohair.offset(arg));
  },
  order: function(arg) {
    return this.fluent('_mohair', this._mohair.order(arg));
  },
  group: function(arg) {
    return this.fluent('_mohair', this._mohair.group(arg));
  },
  "with": function(arg) {
    return this.fluent('_mohair', this._mohair["with"](arg));
  },
  returning: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).returning.apply(_ref, args));
  },
  setConnection: function(arg) {
    var typeofArg;
    typeofArg = typeof arg;
    if (!(('function' === typeof arg) || (('object' === typeof arg) && (arg.query != null)))) {
      throw new Error('.setConnection() must be called with either a connection object or a function that takes a callback and calls it with a connection');
    }
    return this.fluent('_connection', arg);
  },
  getConnection: function(arg) {
    var connection, debug, that;
    that = this;
    if (arg != null) {
      throw new Error(helpers.ignoredArgumentWarning('.getConnection()'));
    }
    connection = this._connection;
    debug = this._debug;
    if (connection == null) {
      return Promise.reject(new Error("the method you are calling requires a call to .setConnection() before it"));
    }
    return new Promise(function(resolve, reject) {
      if ('function' === typeof connection) {
        return connection(function(err, result, realDone) {
          var done;
          done = function() {
            if (typeof debug === "function") {
              debug('connection', 'done', {}, {
                connection: connection
              }, that);
            }
            return realDone();
          };
          if (err != null) {
            if (typeof done === "function") {
              done();
            }
            return reject(err);
          }
          if (typeof debug === "function") {
            debug('connection', 'fresh', {}, {
              connection: result,
              done: done
            }, that);
          }
          return resolve({
            connection: result,
            done: done
          });
        });
      }
      if (typeof debug === "function") {
        debug('connection', 'reuse', {}, {
          connection: connection
        }, that);
      }
      return resolve({
        connection: connection
      });
    });
  },
  wrapInConnection: function(block) {
    return this.getConnection().then(function(_arg) {
      var connection, done;
      connection = _arg.connection, done = _arg.done;
      return block(connection)["finally"](function() {
        return typeof done === "function" ? done() : void 0;
      });
    });
  },
  query: function(sql, params) {
    var debug, that;
    that = this;
    debug = this._debug;
    return this.wrapInConnection(function(connection) {
      return new Promise(function(resolve, reject) {
        if (typeof debug === "function") {
          debug('query', 'before', {
            sql: sql,
            params: params
          }, {
            connection: connection
          }, that);
        }
        return connection.query(sql, params, function(err, results) {
          if (typeof debug === "function") {
            debug('query', 'after', {
              sql: sql,
              params: params
            }, {
              connection: connection,
              err: err,
              results: results
            }, that);
          }
          if (err != null) {
            return reject(err);
          }
          return resolve(results);
        });
      });
    });
  },
  wrapInTransaction: function(block) {
    var debug, that;
    that = this;
    debug = this._debug;
    return this.wrapInConnection(function(connection) {
      var withConnection;
      withConnection = that.setConnection(connection);
      if (typeof debug === "function") {
        debug('transaction', 'begin', {}, {
          connection: connection,
          block: block
        }, that);
      }
      return withConnection.query('BEGIN;').then(function() {
        return block(connection);
      }).then(function(result) {
        if (typeof debug === "function") {
          debug('transaction', 'commit', {}, {
            connection: connection,
            block: block
          }, that);
        }
        return withConnection.query('COMMIT;').then(function() {
          return result;
        });
      })["catch"](function(error) {
        if (typeof debug === "function") {
          debug('transaction', 'rollback', {
            error: error
          }, {
            connection: connection,
            block: block
          }, that);
        }
        return withConnection.query('ROLLBACK;').then(function() {
          return Promise.reject(error);
        });
      });
    });
  },
  runQueue: function(queue, value) {
    var context, reducer;
    context = this;
    reducer = function(soFar, step) {
      return soFar.then(step.bind(context));
    };
    return queue.reduce(reducer, Promise.resolve(value));
  },
  afterQuery: function(results, options) {
    var debug, rows, that;
    that = this;
    debug = this._debug;
    rows = results.rows;
    if (!rows) {
      return results;
    }
    if (typeof debug === "function") {
      debug('after-query', 'before-queue', {
        rows: rows
      }, options, that);
    }
    return this.runQueue(options.after, rows).map(this.runQueue.bind(this, options.afterEach)).then(function(rows) {
      if (typeof debug === "function") {
        debug('after-query', 'after-queue', {
          rows: rows
        }, options, that);
      }
      if (options.returnFirst) {
        return rows[0];
      } else {
        return rows;
      }
    });
  },
  insert: function() {
    var args, debug, records, returnFirst, that;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    that = this;
    debug = this._debug;
    records = _.flatten(args);
    if (records.length === 0) {
      throw new Error('no records to insert');
    }
    returnFirst = args.length === 1 && !Array.isArray(args[0]);
    if (typeof debug === "function") {
      debug('insert', 'before-queue', {
        records: records
      }, {}, that);
    }
    return this.runQueue(this._queueBeforeInsert, records).map(this.runQueue.bind(this, this._queueBeforeEachInsert)).then(function(records) {
      var query, sql;
      if (typeof debug === "function") {
        debug('insert', 'after-queue', {
          records: records
        }, {}, that);
      }
      records.forEach(function(record, index) {
        if (Object.keys(record).length === 0) {
          throw new Error("insert would fail because record at index " + index + " is empty after processing before queue");
        }
      });
      query = that._mohair.insert(records);
      sql = helpers.replacePlaceholders(query.sql());
      return that.query(sql, query.params()).then(function(results) {
        return that.afterQuery(results, {
          returnFirst: returnFirst,
          after: that._queueAfterInsert,
          afterEach: that._queueAfterEachInsert
        });
      });
    });
  },
  update: function(update) {
    var debug, that;
    that = this;
    debug = this._debug;
    if (typeof debug === "function") {
      debug('update', 'before-queue', {
        update: update
      }, {}, that);
    }
    return this.runQueue(this._queueBeforeEachUpdate, update).then(function(update) {
      var query, sql;
      if (typeof debug === "function") {
        debug('update', 'after-queue', {
          update: update
        }, {}, that);
      }
      query = that._mohair.update(update);
      sql = helpers.replacePlaceholders(query.sql());
      return that.query(sql, query.params()).then(function(results) {
        return that.afterQuery(results, {
          returnFirst: that._returnFirst,
          after: that._queueAfterUpdate,
          afterEach: that._queueAfterEachUpdate
        });
      });
    });
  },
  "delete": function() {
    var query, sql, that;
    if (typeof arg !== "undefined" && arg !== null) {
      throw new Error(helpers.ignoredArgumentWarning('.delete()'));
    }
    that = this;
    query = that._mohair["delete"]();
    sql = helpers.replacePlaceholders(query.sql());
    return that.query(sql, query.params()).then(function(results) {
      return that.afterQuery(results, {
        returnFirst: that._returnFirst,
        after: that._queueAfterDelete,
        afterEach: that._queueAfterEachDelete
      });
    });
  },
  find: function(arg) {
    var sql, that;
    if (arg != null) {
      throw new Error(helpers.ignoredArgumentWarning('.find()'));
    }
    that = this;
    sql = helpers.replacePlaceholders(that.sql());
    return that.query(sql, that.params()).then(function(results) {
      return that.afterQuery(results, {
        returnFirst: that._returnFirst,
        after: that._queueAfterSelect,
        afterEach: that._queueAfterEachSelect
      });
    });
  },
  first: function(arg) {
    if (arg != null) {
      throw new Error(helpers.ignoredArgumentWarning('.first()'));
    }
    return this.limit(1).returnFirst().find();
  },
  exists: function(arg) {
    var query, sql;
    if (arg != null) {
      throw new Error(helpers.ignoredArgumentWarning('.exists()'));
    }
    query = this._mohair.limit(1);
    sql = helpers.replacePlaceholders(query.sql());
    return this.query(sql, query.params()).then(function(results) {
      return (results.rows != null) && results.rows.length !== 0;
    });
  },
  call: function() {
    var args, f;
    f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return f.apply(this, args);
  },
  helpers: helpers
};

payload = function() {
  var args, f;
  f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  if (args.length === 0) {
    return f;
  } else {
    return _.partialRight.apply(_, [f].concat(__slice.call(args)));
  }
};

setQueueProperties = function(object, suffix) {
  var dataPropertyName, setterPropertyName;
  setterPropertyName = 'queue' + suffix;
  dataPropertyName = '_' + setterPropertyName;
  object[dataPropertyName] = [];
  return object[setterPropertyName] = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent(dataPropertyName, this[dataPropertyName].concat([payload.apply(null, args)]));
  };
};

setQueueProperties(mesa, 'BeforeInsert');

setQueueProperties(mesa, 'BeforeEachInsert');

setQueueProperties(mesa, 'BeforeEachUpdate');

_ref = ['Select', 'Insert', 'Update', 'Delete'];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  phase = _ref[_i];
  setQueueProperties(mesa, 'After' + phase);
  setQueueProperties(mesa, 'AfterEach' + phase);
}

mesa.queueBeforeEach = function() {
  var args, object;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  object = Object.create(this);
  ['Insert', 'Update'].forEach(function(phase) {
    var propertyName;
    propertyName = '_queueBeforeEach' + phase;
    return object[propertyName] = object[propertyName].concat([payload.apply(null, args)]);
  });
  return object;
};

mesa.queueAfter = function() {
  var args, object;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  object = Object.create(this);
  ['Select', 'Insert', 'Update', 'Delete'].forEach(function(phase) {
    var propertyName;
    propertyName = '_queueAfter' + phase;
    return object[propertyName] = object[propertyName].concat([payload.apply(null, args)]);
  });
  return object;
};

mesa.queueAfterEach = function() {
  var args, object;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  object = Object.create(this);
  ['Select', 'Insert', 'Update', 'Delete'].forEach(function(phase) {
    var propertyName;
    propertyName = '_queueAfterEach' + phase;
    return object[propertyName] = object[propertyName].concat([payload.apply(null, args)]);
  });
  return object;
};

module.exports = mesa.queueBeforeEach(mesa.pickAllowed);
