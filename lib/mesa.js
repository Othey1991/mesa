// Generated by CoffeeScript 1.8.0
var Promise, helpers, mesa, mohair, payload, phase, setQueueProperties, _, _i, _len, _ref,
  __slice = [].slice;

mohair = require('mohair');

Promise = require('bluebird');

_ = require('lodash');

helpers = {};

helpers.schemaAwareEscape = function(string) {
  return string.split('.').map(function(str) {
    return "\"" + str + "\"";
  }).join('.');
};

helpers.defaultMohair = mohair.escape(helpers.schemaAwareEscape).returning('*');

helpers.replacePlaceholders = function(sql) {
  var index;
  index = 1;
  return sql.replace(/\?/g, function() {
    return '$' + index++;
  });
};

helpers.ignoredArgumentWarning = function(receiver) {
  return "you called " + receiver + " with an argument but " + receiver + " ignores all arguments. " + receiver + " returns a promise and maybe you wanted to call that promise instead: " + receiver + ".then(function(result) { ... })";
};

helpers.normalizeLink = function(leftTable, rightTable, immutableLink) {
  var leftTableName, link, rightTableName;
  leftTableName = leftTable.getTable();
  rightTableName = rightTable.getTable();
  link = immutableLink != null ? _.clone(immutableLink) : {};
  if (link.forward == null) {
    link.forward = true;
  }
  if (link.first == null) {
    link.first = false;
  }
  if (link.left == null) {
    if (link.forward) {
      link.left = leftTable.getPrimaryKey();
    } else {
      if (rightTableName == null) {
        throw new Error('default for embed option `thisKey` requires call to .table(name) on this table');
      }
      link.left = rightTableName + '_' + rightTable.getPrimaryKey();
    }
  }
  if (link.right == null) {
    if (link.forward) {
      if (leftTableName == null) {
        throw new Error('default for embed option `otherKey` requires call to .table(name) on other table');
      }
      link.right = leftTableName + '_' + leftTable.getPrimaryKey();
    } else {
      link.right = rightTable.getPrimaryKey();
    }
  }
  if (link.as === true) {
    if (rightTableName == null) {
      throw new Error('default for embed option `as` requires call to .table(name) on other table');
    }
    link.as = rightTableName;
    if (!link.first) {
      link.as += 's';
    }
  }
  return link;
};

helpers.normalizeIncludeArguments = function() {
  var args, lastIndex, leftTable, link, normalized;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  normalized = [];
  leftTable = null;
  link = null;
  lastIndex = args.length - 1;
  args.forEach(function(arg, index) {
    var rightTable;
    if (helpers.isMesa(arg)) {
      if (leftTable != null) {
        link = link != null ? _.clone(link) : {};
        if (index === lastIndex) {
          if (link.as == null) {
            link.as = true;
          }
        }
        rightTable = arg;
        link = helpers.normalizeLink(leftTable, rightTable, link);
        link.table = rightTable;
        normalized.push(link);
        link = null;
      }
      return leftTable = arg;
    } else {
      return link = arg;
    }
  });
  return normalized;
};

mesa = {
  fluent: function(key, value) {
    var object;
    object = Object.create(this);
    object[key] = value;
    return object;
  },
  _returnFirst: false,
  returnFirst: function(arg) {
    if (arg == null) {
      arg = true;
    }
    return this.fluent('_returnFirst', arg);
  },
  debug: function(arg) {
    return this.fluent('_debug', arg);
  },
  call: function() {
    var args, f;
    f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return f.apply(this, args);
  },
  _allowed: [],
  allow: function() {
    var columns;
    columns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_allowed', _.flatten(columns));
  },
  _isUnsafe: false,
  unsafe: function(isUnsafe) {
    if (isUnsafe == null) {
      isUnsafe = true;
    }
    return this.fluent('_isUnsafe', isUnsafe);
  },
  pickAllowed: function(record) {
    if (this._isUnsafe) {
      return record;
    }
    if (this._allowed.length === 0) {
      throw new Error(['no columns are allowed.', 'this will make .update() or .insert() fail.', 'call .allow(columns...) with at least one column before .insert() or .update().', 'alternatively call .unsafe() before to disable mass assignment protection altogether.'].join(' '));
    }
    return _.pick(record, this._allowed);
  },
  _mohair: helpers.defaultMohair,
  sql: function(escape) {
    return this._mohair.sql(escape);
  },
  params: function() {
    return this._mohair.params();
  },
  raw: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (_ref = this._mohair).raw.apply(_ref, args);
  },
  table: function(arg) {
    return this.fluent('_mohair', this._mohair.table(arg));
  },
  getTable: function() {
    return this._mohair.getTable();
  },
  from: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).from.apply(_ref, args));
  },
  where: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).where.apply(_ref, args));
  },
  having: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).having.apply(_ref, args));
  },
  join: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).join.apply(_ref, args));
  },
  select: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).select.apply(_ref, args));
  },
  limit: function(arg) {
    return this.fluent('_mohair', this._mohair.limit(arg));
  },
  offset: function(arg) {
    return this.fluent('_mohair', this._mohair.offset(arg));
  },
  order: function(arg) {
    return this.fluent('_mohair', this._mohair.order(arg));
  },
  group: function(arg) {
    return this.fluent('_mohair', this._mohair.group(arg));
  },
  "with": function(arg) {
    return this.fluent('_mohair', this._mohair["with"](arg));
  },
  returning: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).returning.apply(_ref, args));
  },
  distinct: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).distinct.apply(_ref, args));
  },
  "for": function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair)["for"].apply(_ref, args));
  },
  window: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).window.apply(_ref, args));
  },
  setConnection: function(arg) {
    var typeofArg;
    typeofArg = typeof arg;
    if (!(('function' === typeof arg) || (('object' === typeof arg) && (arg.query != null)))) {
      throw new Error('.setConnection() must be called with either a connection object or a function that takes a callback and calls it with a connection');
    }
    return this.fluent('_connection', arg);
  },
  getConnection: function(arg) {
    var connection, debug, that;
    that = this;
    if (arg != null) {
      throw new Error(helpers.ignoredArgumentWarning('.getConnection()'));
    }
    connection = this._connection;
    debug = this._debug;
    if (connection == null) {
      return Promise.reject(new Error("the method you are calling requires a call to .setConnection() before it"));
    }
    return new Promise(function(resolve, reject) {
      if ('function' === typeof connection) {
        return connection(function(err, result, realDone) {
          var done;
          done = function() {
            if (typeof debug === "function") {
              debug('connection', 'done', {}, {
                connection: connection
              }, that);
            }
            return realDone();
          };
          if (err != null) {
            if (typeof done === "function") {
              done();
            }
            return reject(err);
          }
          if (typeof debug === "function") {
            debug('connection', 'fresh', {}, {
              connection: result,
              done: done
            }, that);
          }
          return resolve({
            connection: result,
            done: done
          });
        });
      }
      if (typeof debug === "function") {
        debug('connection', 'reuse', {}, {
          connection: connection
        }, that);
      }
      return resolve({
        connection: connection
      });
    });
  },
  wrapInConnection: function(block) {
    return this.getConnection().then(function(_arg) {
      var connection, done;
      connection = _arg.connection, done = _arg.done;
      return block(connection)["finally"](function() {
        return typeof done === "function" ? done() : void 0;
      });
    });
  },
  query: function(sql, params) {
    var debug, that;
    that = this;
    debug = this._debug;
    return this.wrapInConnection(function(connection) {
      return new Promise(function(resolve, reject) {
        if (typeof debug === "function") {
          debug('query', 'before', {
            sql: sql,
            params: params
          }, {
            connection: connection
          }, that);
        }
        return connection.query(sql, params, function(err, results) {
          if (typeof debug === "function") {
            debug('query', 'after', {
              sql: sql,
              params: params
            }, {
              connection: connection,
              err: err,
              results: results
            }, that);
          }
          if (err != null) {
            return reject(err);
          }
          return resolve(results);
        });
      });
    });
  },
  wrapInTransaction: function(block) {
    var debug, that;
    that = this;
    debug = this._debug;
    return this.wrapInConnection(function(connection) {
      var withConnection;
      withConnection = that.setConnection(connection);
      if (typeof debug === "function") {
        debug('transaction', 'begin', {}, {
          connection: connection,
          block: block
        }, that);
      }
      return withConnection.query('BEGIN;').then(function() {
        return block(connection);
      }).then(function(result) {
        if (typeof debug === "function") {
          debug('transaction', 'commit', {}, {
            connection: connection,
            block: block
          }, that);
        }
        return withConnection.query('COMMIT;').then(function() {
          return result;
        });
      })["catch"](function(error) {
        if (typeof debug === "function") {
          debug('transaction', 'rollback', {
            error: error
          }, {
            connection: connection,
            block: block
          }, that);
        }
        return withConnection.query('ROLLBACK;').then(function() {
          return Promise.reject(error);
        });
      });
    });
  },
  runQueue: function(queue, value) {
    var context, reducer;
    context = this;
    reducer = function(soFar, step) {
      return soFar.then(step.bind(context));
    };
    return queue.reduce(reducer, Promise.resolve(value));
  },
  afterQuery: function(results, options) {
    var debug, rows, that;
    that = this;
    debug = this._debug;
    rows = results.rows;
    if (!rows) {
      return results;
    }
    if (typeof debug === "function") {
      debug('after-query', 'before-queue', {
        rows: rows
      }, options, that);
    }
    return this.runQueue(options.after, rows).map(this.runQueue.bind(this, options.afterEach)).then(function(rows) {
      if (typeof debug === "function") {
        debug('after-query', 'after-queue', {
          rows: rows
        }, options, that);
      }
      if (options.returnFirst) {
        return rows[0];
      } else {
        return rows;
      }
    });
  },
  insert: function() {
    var args, debug, records, returnFirst, that;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    that = this;
    debug = this._debug;
    records = _.flatten(args);
    if (records.length === 0) {
      throw new Error('no records to insert');
    }
    returnFirst = args.length === 1 && !Array.isArray(args[0]);
    if (typeof debug === "function") {
      debug('insert', 'before-queue', {
        records: records
      }, {}, that);
    }
    return this.runQueue(this._queueBeforeInsert, records).map(this.runQueue.bind(this, this._queueBeforeEachInsert)).then(function(records) {
      var query, sql;
      if (typeof debug === "function") {
        debug('insert', 'after-queue', {
          records: records
        }, {}, that);
      }
      records.forEach(function(record, index) {
        if (Object.keys(record).length === 0) {
          throw new Error("insert would fail because record at index " + index + " is empty after processing before queue");
        }
      });
      query = that._mohair.insert(records);
      sql = helpers.replacePlaceholders(query.sql());
      return that.query(sql, query.params()).then(function(results) {
        return that.afterQuery(results, {
          returnFirst: returnFirst,
          after: that._queueAfterInsert,
          afterEach: that._queueAfterEachInsert
        });
      });
    });
  },
  update: function(update) {
    var debug, that;
    that = this;
    debug = this._debug;
    if (typeof debug === "function") {
      debug('update', 'before-queue', {
        update: update
      }, {}, that);
    }
    return this.runQueue(this._queueBeforeEachUpdate, update).then(function(update) {
      var query, sql;
      if (typeof debug === "function") {
        debug('update', 'after-queue', {
          update: update
        }, {}, that);
      }
      query = that._mohair.update(update);
      sql = helpers.replacePlaceholders(query.sql());
      return that.query(sql, query.params()).then(function(results) {
        return that.afterQuery(results, {
          returnFirst: that._returnFirst,
          after: that._queueAfterUpdate,
          afterEach: that._queueAfterEachUpdate
        });
      });
    });
  },
  "delete": function() {
    var query, sql, that;
    if (typeof arg !== "undefined" && arg !== null) {
      throw new Error(helpers.ignoredArgumentWarning('.delete()'));
    }
    that = this;
    query = that._mohair["delete"]();
    sql = helpers.replacePlaceholders(query.sql());
    return that.query(sql, query.params()).then(function(results) {
      return that.afterQuery(results, {
        returnFirst: that._returnFirst,
        after: that._queueAfterDelete,
        afterEach: that._queueAfterEachDelete
      });
    });
  },
  find: function(arg) {
    var sql, that;
    if (arg != null) {
      throw new Error(helpers.ignoredArgumentWarning('.find()'));
    }
    that = this;
    sql = helpers.replacePlaceholders(that.sql());
    return that.query(sql, that.params()).then(function(results) {
      return that.afterQuery(results, {
        returnFirst: that._returnFirst,
        after: that._queueAfterSelect,
        afterEach: that._queueAfterEachSelect
      });
    });
  },
  first: function(arg) {
    if (arg != null) {
      throw new Error(helpers.ignoredArgumentWarning('.first()'));
    }
    return this.limit(1).returnFirst().find();
  },
  exists: function(arg) {
    var query, sql;
    if (arg != null) {
      throw new Error(helpers.ignoredArgumentWarning('.exists()'));
    }
    query = this._mohair.limit(1);
    sql = helpers.replacePlaceholders(query.sql());
    return this.query(sql, query.params()).then(function(results) {
      return (results.rows != null) && results.rows.length !== 0;
    });
  },
  _primaryKey: 'id',
  primaryKey: function(arg) {
    return this.fluent('_primaryKey', arg);
  },
  getPrimaryKey: function() {
    return this._primaryKey;
  },
  baseEmbed: function(originalRecords, includes) {
    var groupedByFirst, prevRecords, reducer;
    groupedByFirst = null;
    prevRecords = originalRecords;
    reducer = function(soFar, include) {
      return soFar.then(function() {
        var condition;
        condition = {};
        condition[include.right] = _.pluck(prevRecords, include.left);
        return include.table.where(condition).find().then(function(nextRecords) {
          var groupedByCurrent;
          groupedByCurrent = _.groupBy(nextRecords, include.right);
          groupedByFirst = groupedByFirst == null ? groupedByCurrent : _.mapValues(groupedByFirst, function(records) {
            return _.reduce(records, (function(acc, record) {
              records = groupedByCurrent[record[include.left]];
              if (records != null) {
                return acc.concat(records);
              } else {
                return acc;
              }
            }), []);
          });
          if (include.as != null) {
            originalRecords.forEach(function(record) {
              var group;
              group = groupedByFirst[record[includes[0].left]] || [];
              if (include.first) {
                if (group[0] != null) {
                  return record[include.as] = group[0];
                }
              } else {
                return record[include.as] = group;
              }
            });
          }
          return prevRecords = nextRecords;
        });
      });
    };
    return includes.reduce(reducer, Promise.resolve()).then(function() {
      return originalRecords;
    });
  },
  embed: function() {
    var args, records;
    records = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return this.baseEmbed(records, helpers.normalizeIncludeArguments.apply(helpers, [this].concat(__slice.call(args))));
  },
  include: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.queueAfter(_.partialRight.apply(_, [this.embed].concat(__slice.call(args))));
  }
};

payload = function() {
  var args, f;
  f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  if (args.length === 0) {
    return f;
  } else {
    return _.partialRight.apply(_, [f].concat(__slice.call(args)));
  }
};

setQueueProperties = function(object, suffix) {
  var dataPropertyName, setterPropertyName;
  setterPropertyName = 'queue' + suffix;
  dataPropertyName = '_' + setterPropertyName;
  object[dataPropertyName] = [];
  return object[setterPropertyName] = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent(dataPropertyName, this[dataPropertyName].concat([payload.apply(null, args)]));
  };
};

setQueueProperties(mesa, 'BeforeInsert');

setQueueProperties(mesa, 'BeforeEachInsert');

setQueueProperties(mesa, 'BeforeEachUpdate');

_ref = ['Select', 'Insert', 'Update', 'Delete'];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  phase = _ref[_i];
  setQueueProperties(mesa, 'After' + phase);
  setQueueProperties(mesa, 'AfterEach' + phase);
}

mesa.queueBeforeEach = function() {
  var args, object;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  object = Object.create(this);
  ['Insert', 'Update'].forEach(function(phase) {
    var propertyName;
    propertyName = '_queueBeforeEach' + phase;
    return object[propertyName] = object[propertyName].concat([payload.apply(null, args)]);
  });
  return object;
};

mesa.queueAfter = function() {
  var args, object;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  object = Object.create(this);
  ['Select', 'Insert', 'Update', 'Delete'].forEach(function(phase) {
    var propertyName;
    propertyName = '_queueAfter' + phase;
    return object[propertyName] = object[propertyName].concat([payload.apply(null, args)]);
  });
  return object;
};

mesa.queueAfterEach = function() {
  var args, object;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  object = Object.create(this);
  ['Select', 'Insert', 'Update', 'Delete'].forEach(function(phase) {
    var propertyName;
    propertyName = '_queueAfterEach' + phase;
    return object[propertyName] = object[propertyName].concat([payload.apply(null, args)]);
  });
  return object;
};

mesa.isMesa = helpers.isMesa = function(object) {
  return mesa.isPrototypeOf(object);
};

module.exports = mesa.queueBeforeEach(mesa.pickAllowed);

module.exports.helpers = helpers;
