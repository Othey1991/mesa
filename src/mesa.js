// Generated by CoffeeScript 1.8.0
var Promise, afterQuery, defaultMohair, mohair, runPipeline, schemaAwareEscape,
  __slice = [].slice;

mohair = require('mohair');

Promise = require('bluebird');

schemaAwareEscape = function(string) {
  return string.split(".").map(function(str) {
    return "\"" + str + "\"";
  }).join('.');
};

defaultMohair = mohair.escape(schemaAwareEscape).returning('*');

runPipeline = function(context, pipeline, record) {
  var reducer;
  reducer = function(soFar, step) {
    return soFar.then(step.bind(context));
  };
  return pipeline.reduce(reducer, Promise.resolve(record));
};

afterQuery = function(context, returnFirst, pipeline, queryResults) {
  var processRow;
  if (queryResults.rows != null) {
    processRow = function(row) {
      return runPipeline(context, pipeline, row);
    };
    return Promise.all(queryResults.rows.map(processRow)).then(function(processedRows) {
      if (returnFirst) {
        return processedRows[0];
      } else {
        return processedRows;
      }
    });
  } else {
    return results;
  }
};

module.exports = {
  clone: function() {
    return Object.create(this);
  },
  fluent: function(key, value) {
    var object;
    object = this.clone();
    object[key] = value;
    return object;
  },
  _allowedColumns: [],
  allowedColumns: function(columns) {
    return this.fluent('_allowedColumns', this._allowedColumns.concat(columns));
  },
  _returnFirst: false,
  returnFirst: function(arg) {
    if (arg == null) {
      arg = true;
    }
    return this.fluent('_returnFirst', arg);
  },
  table: function(arg) {
    return this.fluent('_table', arg).fluent('_mohair', this._mohair.table(arg));
  },
  debug: function(arg) {
    return this.fluent('_debug', arg);
  },
  _beforeInsert: [],
  beforeInsert: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_beforeInsert', this._beforeInsert.concat(args));
  },
  _afterInsert: [],
  afterInsert: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_afterInsert', this._afterInsert.concat(args));
  },
  _beforeUpdate: [],
  beforeUpdate: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_beforeUpdate', this._beforeUpdate.concat(args));
  },
  _afterUpdate: [],
  afterUpdate: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_afterUpdate', this._afterUpdate.concat(args));
  },
  _afterDelete: [],
  afterDelete: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_afterUpdate', this._afterUpdate.concat(args));
  },
  _afterSelect: [],
  afterSelect: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_afterSelect', this._afterSelect.concat(args));
  },
  _mohair: defaultMohair,
  sql: function(escape) {
    return this._mohair.sql(escape);
  },
  params: function() {
    return this._mohair.params();
  },
  raw: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (_ref = this._mohair).raw.apply(_ref, args);
  },
  where: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).where.apply(_ref, args));
  },
  having: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).having.apply(_ref, args));
  },
  join: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).join.apply(_ref, args));
  },
  select: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).select.apply(_ref, args));
  },
  limit: function(arg) {
    return this.fluent('_mohair', this._mohair.limit(arg));
  },
  offset: function(arg) {
    return this.fluent('_mohair', this._mohair.offset(arg));
  },
  order: function(arg) {
    return this.fluent('_mohair', this._mohair.order(arg));
  },
  group: function(arg) {
    return this.fluent('_mohair', this._mohair.group(arg));
  },
  "with": function(arg) {
    return this.fluent('_mohair', this._mohair["with"](arg));
  },
  returning: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).returning.apply(_ref, args));
  },
  connection: function(arg) {
    return this.fluent('_connection', arg);
  },
  getConnection: function(cb) {
    var connection;
    connection = this._connection;
    if (connection == null) {
      throw new Error("the method you are calling requires a call to connection() before it");
    }
    if ('function' === typeof connection) {
      connection(cb);
      return;
    }
    return setTimeout(function() {
      return cb(null, connection);
    });
  },
  query: function(sql, params) {
    var getConnection;
    getConnection = this.getConnection.bind(this);
    if (typeof this._debug === "function") {
      this._debug({
        method: 'query',
        sql: sql,
        params: params
      });
    }
    return new Promise(function(resolve, reject) {
      return getConnection(function(err, connection, done) {
        if (err != null) {
          if (typeof done === "function") {
            done();
          }
          reject(err);
          return;
        }
        return connection.query(sql, params, function(err, results) {
          if (typeof done === "function") {
            done();
          }
          if (err != null) {
            reject(err);
            return;
          }
          return resolve(results);
        });
      });
    });
  },
  insert: function(recordOrRecords) {
    var beforeInsert, isArray, records, returnFirst, that;
    that = this;
    isArray = Array.isArray(recordOrRecords);
    if (isArray) {
      if (typeof this._debug === "function") {
        this._debug({
          method: 'insert',
          records: recordOrRecords
        });
      }
    } else {
      if (typeof this._debug === "function") {
        this._debug({
          method: 'insert',
          record: recordOrRecords
        });
      }
    }
    returnFirst = !isArray;
    records = isArray ? recordOrRecords : [recordOrRecords];
    beforeInsert = function(record) {
      return runPipeline(that, that._beforeInsert, record);
    };
    return Promise.all(records.map(beforeInsert)).then(function(processedArray) {
      var cleanArray, query, sql;
      cleanArray = processedArray.map(function(record) {
        return that.pickAllowedColumns(record);
      });
      query = that._mohair.insert(cleanArray);
      sql = that.replacePlaceholders(query.sql());
      return that.query(sql, query.params()).then(function(results) {
        return afterQuery(that, returnFirst, that._afterInsert, results);
      });
    });
  },
  update: function(update) {
    var that;
    that = this;
    return runPipeline(that, that._beforeUpdate, update).then(function(processedData) {
      var cleanData, query, sql;
      cleanData = that.pickAllowedColumns(processedData);
      query = that._mohair.update(cleanData);
      sql = that.replacePlaceholders(query.sql());
      return that.query(sql, query.params()).then(function(results) {
        return afterQuery(that, that._returnFirst, that._afterUpdate, results);
      });
    });
  },
  "delete": function() {
    var query, sql, that;
    that = this;
    query = that._mohair["delete"]();
    sql = that.replacePlaceholders(query.sql());
    return that.query(sql, query.params()).then(function(results) {
      return afterQuery(that, that._returnFirst, that._afterDelete, results);
    });
  },
  find: function(arg) {
    var sql, that;
    if (arg != null) {
      throw new Error("you called `.find()` with an argument but `.find()` ignores all arguments. find returns a promise! maybe you wanted to call the promise instead: `find().then(function(result) { ... })`");
    }
    that = this;
    sql = that.replacePlaceholders(that.sql());
    return that.query(sql, that.params()).then(function(results) {
      return afterQuery(that, that._returnFirst, that._afterSelect, results);
    });
  },
  first: function() {
    return this.limit(1).returnFirst().find();
  },
  exists: function() {
    var query, sql;
    query = this._mohair.limit(1);
    sql = this.replacePlaceholders(query.sql());
    return that.query(sql, query.params()).then(function(results) {
      return (results.rows != null) && results.rows.length !== 0;
    });
  },
  call: function() {
    var args, f;
    f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return f.apply(this, args);
  },
  replacePlaceholders: function(sql) {
    var index;
    index = 1;
    return sql.replace(/\?/g, function() {
      return '$' + index++;
    });
  },
  pickAllowedColumns: function(record) {
    var picked;
    picked = {};
    this._allowedColumns.forEach(function(column) {
      if (column in record) {
        return picked[column] = record[column];
      }
    });
    return picked;
  }
};
