// Generated by CoffeeScript 1.8.0
var Promise, helpers, mohair,
  __slice = [].slice;

mohair = require('mohair');

Promise = require('bluebird');

helpers = {};

helpers.schemaAwareEscape = function(string) {
  return string.split(".").map(function(str) {
    return "\"" + str + "\"";
  }).join('.');
};

helpers.defaultMohair = mohair.escape(helpers.schemaAwareEscape).returning('*');

helpers.runPipeline = function(context, pipeline, record) {
  var reducer;
  reducer = function(soFar, step) {
    return soFar.then(step.bind(context));
  };
  return pipeline.reduce(reducer, Promise.resolve(record));
};

helpers.afterQuery = function(context, returnFirst, pipeline, queryResults) {
  var processRow;
  if (queryResults.rows != null) {
    processRow = function(row) {
      return helpers.runPipeline(context, pipeline, row);
    };
    return Promise.all(queryResults.rows.map(processRow)).then(function(processedRows) {
      if (returnFirst) {
        return processedRows[0];
      } else {
        return processedRows;
      }
    });
  } else {
    return results;
  }
};

helpers.replacePlaceholders = function(sql) {
  var index;
  index = 1;
  return sql.replace(/\?/g, function() {
    return '$' + index++;
  });
};

helpers.pick = function(record, keys) {
  var picked;
  picked = {};
  keys.forEach(function(column) {
    if (column in record) {
      return picked[column] = record[column];
    }
  });
  return picked;
};

helpers.pgDestroyPool = function(pg, config) {
  var pool, poolKey;
  poolKey = JSON.stringify(config);
  console.log('pgDestroyPool');
  console.log('Object.keys(pg.pools.all)', Object.keys(pg.pools.all));
  console.log('poolKey', poolKey);
  pool = pg.pools.all[poolKey];
  console.log('pool?', pool != null);
  if (pool != null) {
    return new Promise(function(resolve, reject) {
      return pool.drain(function() {
        return pool.destroyAllNow(function() {
          delete pg.pools.all[poolKey];
          return resolve();
        });
      });
    });
  } else {
    return Promise.resolve();
  }
};

module.exports = {
  clone: function() {
    return Object.create(this);
  },
  fluent: function(key, value) {
    var object;
    object = this.clone();
    object[key] = value;
    return object;
  },
  _allowedColumns: [],
  allowedColumns: function(columns) {
    return this.fluent('_allowedColumns', this._allowedColumns.concat(columns));
  },
  _returnFirst: false,
  returnFirst: function(arg) {
    if (arg == null) {
      arg = true;
    }
    return this.fluent('_returnFirst', arg);
  },
  table: function(arg) {
    return this.fluent('_table', arg).fluent('_mohair', this._mohair.table(arg));
  },
  debug: function(arg) {
    return this.fluent('_debug', arg);
  },
  _beforeInsert: [],
  beforeInsert: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_beforeInsert', this._beforeInsert.concat(args));
  },
  _afterInsert: [],
  afterInsert: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_afterInsert', this._afterInsert.concat(args));
  },
  _beforeUpdate: [],
  beforeUpdate: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_beforeUpdate', this._beforeUpdate.concat(args));
  },
  _afterUpdate: [],
  afterUpdate: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_afterUpdate', this._afterUpdate.concat(args));
  },
  _afterDelete: [],
  afterDelete: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_afterUpdate', this._afterUpdate.concat(args));
  },
  _afterSelect: [],
  afterSelect: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_afterSelect', this._afterSelect.concat(args));
  },
  _mohair: helpers.defaultMohair,
  sql: function(escape) {
    return this._mohair.sql(escape);
  },
  params: function() {
    return this._mohair.params();
  },
  raw: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (_ref = this._mohair).raw.apply(_ref, args);
  },
  where: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).where.apply(_ref, args));
  },
  having: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).having.apply(_ref, args));
  },
  join: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).join.apply(_ref, args));
  },
  select: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).select.apply(_ref, args));
  },
  limit: function(arg) {
    return this.fluent('_mohair', this._mohair.limit(arg));
  },
  offset: function(arg) {
    return this.fluent('_mohair', this._mohair.offset(arg));
  },
  order: function(arg) {
    return this.fluent('_mohair', this._mohair.order(arg));
  },
  group: function(arg) {
    return this.fluent('_mohair', this._mohair.group(arg));
  },
  "with": function(arg) {
    return this.fluent('_mohair', this._mohair["with"](arg));
  },
  returning: function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (_ref = this._mohair).returning.apply(_ref, args));
  },
  connection: function(arg) {
    return this.fluent('_connection', arg);
  },
  getConnection: function(cb) {
    var connection, debug;
    connection = this._connection;
    debug = this._debug;
    if (connection == null) {
      throw new Error("the method you are calling requires a call to connection() before it");
    }
    return new Promise(function(resolve, reject) {
      if ('function' === typeof connection) {
        return connection(function(err, result, realDone) {
          var done;
          done = function() {
            if (typeof debug === "function") {
              debug({
                event: 'connection .done() called',
                connection: connection
              });
            }
            return realDone();
          };
          if (err != null) {
            if (typeof done === "function") {
              done();
            }
            return reject(err);
          }
          if (typeof debug === "function") {
            debug({
              method: 'getConnection',
              connection: result,
              isNewConnection: true
            });
          }
          return resolve({
            connection: result,
            done: done
          });
        });
      }
      if (typeof debug === "function") {
        debug({
          method: 'getConnection',
          connection: connection,
          isNewConnection: false
        });
      }
      return resolve({
        connection: connection
      });
    });
  },
  wrapInConnection: function(block) {
    return this.getConnection().then(function(_arg) {
      var connection, done;
      connection = _arg.connection, done = _arg.done;
      return block(connection)["finally"](function() {
        return typeof done === "function" ? done() : void 0;
      });
    });
  },
  query: function(sql, params) {
    if (typeof this.debug === "function") {
      this.debug({
        method: 'query',
        sql: sql,
        params: params
      });
    }
    return this.wrapInConnection(function(connection) {
      return new Promise(function(resolve, reject) {
        return connection.query(sql, params, function(err, results) {
          if (err != null) {
            return reject(err);
          }
          return resolve(results);
        });
      });
    });
  },
  wrapInTransaction: function(block) {
    var that;
    that = this;
    return this.wrapInConnection(function(connection) {
      var thatWithConnection;
      thatWithConnection = that.connection(connection);
      if (typeof that.debug === "function") {
        that.debug({
          event: 'transaction start'
        });
      }
      return thatWithConnection.query('BEGIN;').then(function() {
        return block(connection);
      }).then(function(result) {
        if (typeof that.debug === "function") {
          that.debug({
            event: 'transaction commit'
          });
        }
        return thatWithConnection.query('COMMIT;').then(function() {
          return result;
        });
      })["catch"](function(error) {
        if (typeof that.debug === "function") {
          that.debug({
            event: 'transaction rollback',
            error: error
          });
        }
        return thatWithConnection.query('ROLLBACK;').then(function() {
          return Promise.reject(error);
        });
      });
    });
  },
  insert: function(recordOrRecords) {
    var beforeInsert, isArray, records, returnFirst, that;
    that = this;
    isArray = Array.isArray(recordOrRecords);
    if (isArray) {
      if (typeof this._debug === "function") {
        this._debug({
          method: 'insert',
          records: recordOrRecords
        });
      }
    } else {
      if (typeof this._debug === "function") {
        this._debug({
          method: 'insert',
          record: recordOrRecords
        });
      }
    }
    returnFirst = !isArray;
    records = isArray ? recordOrRecords : [recordOrRecords];
    beforeInsert = function(record) {
      return helpers.runPipeline(that, that._beforeInsert, record);
    };
    return Promise.all(records.map(beforeInsert)).then(function(processedArray) {
      var cleanArray, query, sql;
      cleanArray = processedArray.map(function(record) {
        return helpers.pick(record, that._allowedColumns);
      });
      query = that._mohair.insert(cleanArray);
      sql = helpers.replacePlaceholders(query.sql());
      return that.query(sql, query.params()).then(function(results) {
        return helpers.afterQuery(that, returnFirst, that._afterInsert, results);
      });
    });
  },
  update: function(update) {
    var that;
    that = this;
    return helpers.runPipeline(that, that._beforeUpdate, update).then(function(processedData) {
      var cleanData, query, sql;
      cleanData = helpers.pick(processedData, that._allowedColumns);
      query = that._mohair.update(cleanData);
      sql = helpers.replacePlaceholders(query.sql());
      return that.query(sql, query.params()).then(function(results) {
        return helpers.afterQuery(that, that._returnFirst, that._afterUpdate, results);
      });
    });
  },
  "delete": function() {
    var query, sql, that;
    that = this;
    query = that._mohair["delete"]();
    sql = helpers.replacePlaceholders(query.sql());
    return that.query(sql, query.params()).then(function(results) {
      return helpers.afterQuery(that, that._returnFirst, that._afterDelete, results);
    });
  },
  find: function(arg) {
    var sql, that;
    if (arg != null) {
      throw new Error("you called .find() with an argument but .find() ignores all arguments. .find() returns a promise! maybe you wanted to call the promise instead: .find().then(function(result) { ... })");
    }
    that = this;
    sql = helpers.replacePlaceholders(that.sql());
    return that.query(sql, that.params()).then(function(results) {
      return helpers.afterQuery(that, that._returnFirst, that._afterSelect, results);
    });
  },
  first: function(arg) {
    if (arg != null) {
      throw new Error("you called .first() with an argument but .first() ignores all arguments. .first() returns a promise! maybe you wanted to call the promise instead: .first().then(function(result) { ... })");
    }
    return this.limit(1).returnFirst().find();
  },
  exists: function(arg) {
    var query, sql;
    if (arg != null) {
      throw new Error("you called .exists() with an argument but .exists() ignores all arguments. .exists() returns a promise! maybe you wanted to call the promise instead: .exists().then(function(result) { ... })");
    }
    query = this._mohair.limit(1);
    sql = helpers.replacePlaceholders(query.sql());
    return that.query(sql, query.params()).then(function(results) {
      return (results.rows != null) && results.rows.length !== 0;
    });
  },
  call: function() {
    var args, f;
    f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return f.apply(this, args);
  },
  helpers: helpers
};
